name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
    paths:
      - 'app/**'
      - 'k8s/**'
      - 'helm/**'
      - '.github/workflows/**'
  pull_request:
    branches: [ main ]
    paths:
      - 'app/**'
      - 'k8s/**'
      - 'helm/**'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'dev'
        type: choice
        options:
        - dev
        - staging
        - prod

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}/devops-demo-app
  PYTHON_VERSION: '3.11'

jobs:
  # Security and vulnerability scanning
  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Run Trivy vulnerability scanner in repo mode
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'
      
      - name: Upload Trivy scan results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v2
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'
      
      - name: Run GitLeaks secret scanning
        uses: gitleaks/gitleaks-action@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Code quality and testing
  test:
    name: Test and Code Quality
    runs-on: ubuntu-latest
    needs: security-scan
    services:
      redis:
        image: redis:7-alpine
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379
      
      postgres:
        image: postgres:15-alpine
        env:
          POSTGRES_DB: test_db
          POSTGRES_USER: test_user
          POSTGRES_PASSWORD: test_password
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      
      - name: Cache pip dependencies
        uses: actions/cache@v3
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('app/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-
      
      - name: Install dependencies
        run: |
          cd app
          pip install -r requirements.txt
          pip install pylint bandit safety
      
      - name: Run tests with coverage
        env:
          REDIS_HOST: localhost
          REDIS_PORT: 6379
          REDIS_PASSWORD: ""
          POSTGRES_HOST: localhost
          POSTGRES_PORT: 5432
          POSTGRES_DB: test_db
          POSTGRES_USER: test_user
          POSTGRES_PASSWORD: test_password
        run: |
          cd app
          python -m pytest tests/ -v --cov=src --cov-report=xml --cov-report=html
      
      - name: Upload coverage reports to Codecov
        uses: codecov/codecov-action@v3
        with:
          file: ./app/coverage.xml
          flags: unittests
          name: codecov-umbrella
      
      - name: Run Pylint
        run: |
          cd app/src
          pylint *.py --output-format=text --reports=no --score=no || true
      
      - name: Run Bandit security linter
        run: |
          cd app
          bandit -r src/ -f json -o bandit-report.json || true
      
      - name: Check dependencies with Safety
        run: |
          cd app
          safety check --json --output safety-report.json || true
      
      - name: Upload test artifacts
        uses: actions/upload-artifact@v3
        if: always()
        with:
          name: test-reports
          path: |
            app/coverage.xml
            app/htmlcov/
            app/bandit-report.json
            app/safety-report.json

  # Build and push Docker image
  build:
    name: Build and Push Image
    runs-on: ubuntu-latest
    needs: test
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}
      
      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: ./app
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
      
      - name: Run Trivy vulnerability scanner on image
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
          format: 'sarif'
          output: 'trivy-image-results.sarif'
      
      - name: Upload Trivy image scan results
        uses: github/codeql-action/upload-sarif@v2
        if: always()
        with:
          sarif_file: 'trivy-image-results.sarif'

  # Deploy to development environment
  deploy-dev:
    name: Deploy to Development
    runs-on: ubuntu-latest
    needs: build
    if: github.ref == 'refs/heads/develop' || github.event_name == 'workflow_dispatch'
    environment: development
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Helm
        uses: azure/setup-helm@v3
        with:
          version: '3.12.1'
      
      - name: Set up kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: '1.28.0'
      
      - name: Configure kubectl
        run: |
          echo "${{ secrets.KUBECONFIG_DEV }}" | base64 -d > kubeconfig
          export KUBECONFIG=kubeconfig
          kubectl version --client
      
      - name: Deploy with Helm
        env:
          KUBECONFIG: kubeconfig
        run: |
          helm upgrade --install devops-demo-dev ./helm/charts/app \
            --namespace dev \
            --create-namespace \
            --set image.repository=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }} \
            --set image.tag=${{ github.sha }} \
            --set environment=dev \
            --set ingress.hosts[0].host=dev-api.example.com \
            --set replicaCount=2 \
            --wait --timeout=300s
      
      - name: Run smoke tests
        env:
          KUBECONFIG: kubeconfig
        run: |
          # Wait for rollout to complete
          kubectl rollout status deployment/devops-demo-dev -n dev --timeout=300s
          
          # Get service endpoint
          SERVICE_IP=$(kubectl get svc devops-demo-dev -n dev -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          if [ -z "$SERVICE_IP" ]; then
            SERVICE_IP=$(kubectl get svc devops-demo-dev -n dev -o jsonpath='{.spec.clusterIP}')
          fi
          
          # Basic health check
          kubectl run curl-test --image=curlimages/curl:latest --rm -i --restart=Never -- \
            curl -f http://$SERVICE_IP:8000/health

  # Deploy to staging environment
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [build, deploy-dev]
    if: github.ref == 'refs/heads/main'
    environment: staging
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Helm
        uses: azure/setup-helm@v3
        with:
          version: '3.12.1'
      
      - name: Set up kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: '1.28.0'
      
      - name: Configure kubectl
        run: |
          echo "${{ secrets.KUBECONFIG_STAGING }}" | base64 -d > kubeconfig
          export KUBECONFIG=kubeconfig
      
      - name: Blue-Green Deployment to Staging
        env:
          KUBECONFIG: kubeconfig
        run: |
          # Deploy green version
          helm upgrade --install devops-demo-staging-green ./helm/charts/app \
            --namespace staging \
            --create-namespace \
            --set image.repository=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }} \
            --set image.tag=${{ github.sha }} \
            --set environment=staging \
            --set ingress.hosts[0].host=staging-api.example.com \
            --set replicaCount=3 \
            --set blueGreen.enabled=true \
            --set blueGreen.color=green \
            --wait --timeout=300s
          
          # Run integration tests on green
          ./scripts/run-integration-tests.sh staging green
          
          # Switch traffic to green
          kubectl patch service devops-demo-staging -n staging \
            -p '{"spec":{"selector":{"app.kubernetes.io/color":"green"}}}'
          
          # Clean up blue version after successful deployment
          helm uninstall devops-demo-staging-blue -n staging || true

  # Deploy to production environment
  deploy-prod:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [build, deploy-staging]
    if: github.ref == 'refs/heads/main'
    environment: production
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Helm
        uses: azure/setup-helm@v3
        with:
          version: '3.12.1'
      
      - name: Set up kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: '1.28.0'
      
      - name: Configure kubectl
        run: |
          echo "${{ secrets.KUBECONFIG_PROD }}" | base64 -d > kubeconfig
          export KUBECONFIG=kubeconfig
      
      - name: Blue-Green Deployment to Production
        env:
          KUBECONFIG: kubeconfig
        run: |
          # Get current color
          CURRENT_COLOR=$(kubectl get service devops-demo-prod -n production \
            -o jsonpath='{.spec.selector.app\.kubernetes\.io/color}' || echo "blue")
          
          if [ "$CURRENT_COLOR" = "blue" ]; then
            NEW_COLOR="green"
          else
            NEW_COLOR="blue"
          fi
          
          echo "Deploying $NEW_COLOR version to production"
          
          # Deploy new version
          helm upgrade --install devops-demo-prod-$NEW_COLOR ./helm/charts/app \
            --namespace production \
            --create-namespace \
            --set image.repository=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }} \
            --set image.tag=${{ github.sha }} \
            --set environment=production \
            --set ingress.hosts[0].host=api.example.com \
            --set replicaCount=5 \
            --set blueGreen.enabled=true \
            --set blueGreen.color=$NEW_COLOR \
            --wait --timeout=600s
          
          # Run production readiness tests
          ./scripts/run-production-tests.sh $NEW_COLOR
          
          # Gradual traffic shift
          echo "Starting gradual traffic shift to $NEW_COLOR"
          kubectl patch service devops-demo-prod -n production \
            -p "{\"spec\":{\"selector\":{\"app.kubernetes.io/color\":\"$NEW_COLOR\"}}}"
          
          # Monitor for 5 minutes
          sleep 300
          
          # Verify deployment success
          ./scripts/verify-deployment.sh production $NEW_COLOR
          
          # Clean up old version
          if [ "$CURRENT_COLOR" != "" ]; then
            helm uninstall devops-demo-prod-$CURRENT_COLOR -n production || true
          fi

  # Rollback capability
  rollback:
    name: Rollback
    runs-on: ubuntu-latest
    if: failure() && github.ref == 'refs/heads/main'
    needs: [deploy-prod]
    environment: production
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: '1.28.0'
      
      - name: Configure kubectl
        run: |
          echo "${{ secrets.KUBECONFIG_PROD }}" | base64 -d > kubeconfig
          export KUBECONFIG=kubeconfig
      
      - name: Rollback to previous version
        env:
          KUBECONFIG: kubeconfig
        run: |
          # Get helm release history
          helm history devops-demo-prod -n production
          
          # Rollback to previous release
          helm rollback devops-demo-prod -n production 1
          
          # Verify rollback
          kubectl rollout status deployment/devops-demo-prod -n production --timeout=300s